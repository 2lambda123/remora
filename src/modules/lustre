#!/bin/sh
#
#========================================================================
# HEADER
#========================================================================
#% DESCRIPTION
#% lustre
#%
#% DO NOT call this script directly. This is called by REMORA
#%
#========================================================================
#- IMPLEMENTATION
#-      version     REMORA 1.4
#-      authors     Carlos Rosales (carlos@tacc.utexas.edu)
#-                  Antonio Gomez  (agomez@tacc.utexas.edu)
#-      license     MIT
#
#========================================================================
#  HISTORY
#       2015/12/08: Initial commit
#========================================================================

# All the functions take two arguments:
#  1.- The name of the node where this function is running
#  2.- The full path where the output will be stored/read

init_module_lustre()
{
    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            #Capture the "internal" names (IFSNAMES) of the lustre filesystems
            #and the names of the mounts (FSNAMES)
            FSS=`df --type=lustre -P`
            local MOUNTS=()
            local idx=0
            IFSNAMES=()
            FSNAMES=()
            while read -r line; do
                if [ $idx == 0 ]; then
                    idx=$((idx+1))
                    continue
                fi
                IFSNAMES[$idx-1]=`echo $line  | sed 's/.*:\///' | awk '{print $1;}'`
                local TEMP=`echo $line | sed 's/.*:\///' | awk '{print $6;}'`
                FSNAMES[$idx-1]=`echo "${TEMP////}"`
                if [ "$REMORA_VERBOSE" == "1" ]; then
                    echo ${IFSNAMES[$idx-1]} ${FSNAMES[$idx-1]}
                fi
                idx=$((idx+1))
            done <<< "$FSS"

            printf "%-17s %-17s" TIMESTAMP "${FSNAMES[@]}" >> $2/lustre_$1.txt
            printf "\n"  >> $2/lustre_$1.txt
        fi
    fi
}

collect_data_lustre()
{
    # cat /proc/fs/lustre/{mdc,osc}/scratch*/stats | grep waittime | awk '{print $2;}' | paste -sd+ | bc
    # The values scratch, home, gsfs come from "df --type=lustre"

    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            local LUSTRE_DIR_PATH=/proc/fs/lustre
            local TIMESTAMP=`date +%s`
            local idx=0
            local COUNTER=()
            local READS=()
            local WRITES=()
            for fs in "${IFSNAMES[@]}"
            do
                if [ "$REMORA_VERBOSE" == "1" ]; then
                    echo "cat /proc/fs/lustre/{mdc,osc}/$fs*/stats | grep req_waittime | awk '{print \$2;}' | paste -sd+ | bc"
                    echo "cat /proc/fs/lustre/llite/$fs*/stats | grep osc_read | awk '{print $2;}' | paste -sd+ | bc"
                    echo "cat /proc/fs/lustre/llite/$fs*/stats | grep osc_write | awk '{print $2;}' | paste -sd+ | bc"
                fi
                COUNTER[$idx]=`cat /proc/fs/lustre/{mdc,osc}/$fs*/stats | grep req_waittime | awk '{print $2;}' | paste -sd+ | bc`
                READS[$idx]=`cat /proc/fs/lustre/llite/$fs*/stats | grep osc_read | awk '{print $2;}' | paste -sd+ | bc`
                WRITES[$idx]=`cat /proc/fs/lustre/llite/$fs*/stats | grep osc_write | awk '{print $2;}' | paste -sd+ | bc`
				idx=$((idx+1))
            done
            printf "%-17d %-17d" $TIMESTAMP "${COUNTER[@]}" >> $2/lustre_io_$1.txt
            printf "\n"  >> $2/lustre_io_$1.txt
            printf "%-17d %-17d" $TIMESTAMP "${READS[@]}" >> $2/lustre_rd_$1.txt
            printf "\n"  >> $2/lustre_rd_$1.txt
            printf "%-17d %-17d" $TIMESTAMP "${WRITES[@]}" >> $2/lustre_wr_$1.txt
            printf "\n"  >> $2/lustre_wr_$1.txt
        fi
    fi
}

# This function might perform some processing on the data.
# If nothing needs to be done, it can be empty (but declared)
process_data_lustre()
{
  :
}

finalize_module_lustre()
{
  REMORA_NODE_ID=$3
  if [ "$REMORA_NODE_ID" == "0" ]; then 
    # Get names from lustre.txt file headers
    FSNAMES=()
    idx=0
    file=$(ls $REMORA_OUTDIR/lustre_*.txt | awk '{print $1}' | head -n 1)
    for fs in `head -n 1 $file`; do
      if [ "$fs" != "TIMESTAMP" ]; then
        FSNAMES[$idx]=$fs
        idx=$((idx+1))
      fi
    done

    # Identify shortest entry
    # Checks all of io, rd and wr files
    min_len=0
    for file in `ls $2/lustre_*.txt`; do
       fs_col=2; len=0
       for FS in "${FSNAMES[@]}"; do
         len=`cat $file | tr -s ' ' | cut -d ' ' -f $fs_col | wc -l | awk '{print $1}'`
         if [ "$min_len" -eq "0" ] || [ "$len" -lt "$min_len" ]; then 
           min_len=$len
         fi
         fs_col=$((fs_col+1))
       done
     done

    # Generate single file for a given time step
    for op in io rd wr; do
      for i in `seq 2 $min_len`; do 
        for file in `ls $2/lustre_${op}_*.txt`; do
          sed "${i}q;d" $file >> $2/lustre.tmp
        done
        col_id=2
        time_stamp=`head -n 1 $2/lustre.tmp | awk '{print $1}'`
        for FS in "${FSNAMES[@]}"; do
          cat $2/lustre.tmp | tr -s ' ' | cut -d ' ' -f $col_id | awk -v ts="$time_stamp" '{sum+=$1} END {print ts " " sum}' >> $2/lustre_${op}.$FS
          col_id=$((col_id+1))
        done
        rm $2/lustre.tmp
      done
    done

    # Calculate actual data rates from raw counters
    min_len=$((min_len-1))
    for op in io rd wr; do
      for file in `ls $2/lustre_${op}.*`; do
        for i in `seq 1 $min_len`; do
          next=$((i+1))
          t1=`sed "${i}q;d" $file | awk '{ print $1 }'`
          d1=`sed "${i}q;d" $file | awk '{ print $2 }'`
          t2=`sed "${next}q;d" $file | awk '{ print $1 }'`
          d2=`sed "${next}q;d" $file | awk '{ print $2 }'`
          # NOTE 1/0 if t2=t1
          if [ "$op" == "io" ]; then
            value=`echo "scale=4; ( $d2 - $d1 ) / ( $t2 - $t1 )" | bc`
          else
            value=`echo "scale=4; ( $d2 - $d1 ) / ( 1000000* ( $t2 - $t1 ) )" | bc`
          fi
          printf "%-17d %-17f\n" $t1 $value >> $file.rate
        done
      done
    done
  fi
}
