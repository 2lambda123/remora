#!/bin/sh
#
#========================================================================
# HEADER
#========================================================================
#% DESCRIPTION
#% lustre
#%
#% DO NOT call this script directly. This is called by REMORA
#%
#========================================================================
#- IMPLEMENTATION
#-      version     REMORA 1.4
#-      authors     Carlos Rosales (carlos@tacc.utexas.edu)
#-                  Antonio Gomez  (agomez@tacc.utexas.edu)
#-      license     MIT
#
#========================================================================
#  HISTORY
#       2015/12/08: Initial commit
#========================================================================

# All the functions take two arguments:
#  1.- The name of the node where this function is running
#  2.- The full path where the output will be stored/read

init_module_lustre()
{
    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            local LUSTRE_DIR_PATH=/proc/fs/lustre
            local TIMESTAMP=`date +%s`
            for FILE in $LUSTRE_DIR_PATH/{mdc,osc}/*
            do
                if [ -d "${FILE}" ] ; then
                    local FN=`sed -e 's/\/proc\/fs\/lustre//' <<< "$FILE" | cut -d "/" -f 3`
                    local DEVICE=`echo "${FN%%-osc*}"`
                    DEVICE=`echo "${DEVICE%%-mdc*}"`
                    echo "TIMESTAMP     COUNTER" >> $2/lustre_$1_$DEVICE.txt
                fi
            done
        fi
    fi
}

collect_data_lustre()
{
    #We could use this command:
    # cat /proc/fs/lustre/{mdc,osc}/scratch*/stats | grep waittime | awk '{print $2;}' | paste -sd+ | bc
    # cat /proc/fs/lustre/{mdc,osc}/home*/stats | grep waittime | awk '{print $2;}' | paste -sd+ | bc
    # cat /proc/fs/lustre/{mdc,osc}/gsfs*/stats | grep waittime | awk '{print $2;}' | paste -sd+ | bc
    # The values scratch, home, gsfs come from "df --type=lustre"
    if [ "$REMORA_SYMMETRIC" == "0" ]; then
        if [ "$REMORA_MODE" = "FULL" ]; then
            local LUSTRE_DIR_PATH=/proc/fs/lustre
            local TIMESTAMP=`date +%s`
            for FILE in $LUSTRE_DIR_PATH/{mdc,osc}/*
            do
                if [ -d "${FILE}" ] ; then
                    local COUNTER=`grep req_waittime $FILE/stats | awk '{print $2}'`
                    local FN=`sed -e 's/\/proc\/fs\/lustre//' <<< "$FILE" | cut -d "/" -f 3`
                    local DEVICE=`echo "${FN%%-osc*}"`
                    DEVICE=`echo "${DEVICE%%-mdc*}"`
                    printf "%-17d %-17d\n" $TIMESTAMP $COUNTER >> $2/lustre_$1_$DEVICE.txt
                fi
            done
        fi
    fi
}

# This function might perform some processing on the data.
# If nothing needs to be done, it can be empty (but declared)
process_data_lustre()
{
  :
}

finalize_module_lustre()
{
    local FSS=`df --type=lustre -P`

    local MOUNTS=()
    local idx=0
    while read -r line; do
        MOUNTS[$idx]=$line
        idx=$((idx+1))
    done <<< "$FSS"

    local prefix=$2/lustre_$1_
    local sufix=".txt"
    FILES="$2/lustre_$1_*.txt"
    #Matrix that stores, for each filesystem, for each timestamp, the
    #aggregated value of the counter
    declare -A matrix
    declare -A timestamps
    filesystems=()

    for FILE in $FILES
    do
        #Sanity check
        if [ "$FILE" == "$2/lustre_$1_.txt" ]; then
            continue
        fi
        local foo=${FILE#$prefix}
        local DEVICE=${foo%$sufix}
        DEVICE=${DEVICE//-[OST,MDT]*/}
        local fs_name=""
        local is_new=0
        for MOUNT in "${MOUNTS[@]}"
        do
            #Get the line where the given DEVICE is mounted
            #echo "Checking $MOUNT -- DEVICE $DEVICE"
            local FS=`echo $MOUNT | grep $DEVICE`
            if [ ! -z "$FS" ]; then
                #get the last column
                local temp=`echo -e "$FS" | awk '{print $NF}'`
                #Remove any "/" character
                fs_name=${temp//\/}
                #Here, fs_name has the name that the user sees in the different filesystems
                #Right now we just print this. I'll finish this tomorrow
                #echo $fs_name
                is_new=0
                if [[ " ${filesystems[*]} " == *" $fs_name "* ]]; then
                    is_new=0
                else
                    filesystems+=($fs_name)
                    is_new=1
                    #echo ${filesystems[*]}
                fi
                break
            fi
        done
        idx=0
        while IFS='' read -r line || [[ -n "$line" ]]; do
            idx=$((idx+1))
            if [ $idx == 1 ]; then
                continue
            fi
            local timestamp=`echo $line | awk '{print $1;}'`
            local counter=`echo $line | awk '{print $2;}'`
            #echo "COUNTER: $counter"
            if [ "$is_new" == "1" ]; then
                matrix[$fs_name,$idx]=$counter
                timestamps[$fs_name]=$idx
            else
                local prev_val=`printf "%d" ${matrix[$fs_name,$idx]}`
                #echo "Previous value $prev_val"
                matrix[$fs_name,$idx]=$((prev_val + counter))
            fi
            #printf "Matrix[$fs_name, $idx] val: %d\n" ${matrix[$fs_name,$idx]}
        done < "$FILE"
        #Move file to another folder (to make it more user-friendly)
        mkdir -p $2/.lustre_output
        mv $FILE $2/.lustre_output/
    done
    for fs in "${filesystems[@]}"
    do
        local ts=`printf "%d" ${timestamps[$fs]}`
        #echo "FS: $fs --- timestamps: $ts"
        idx=1
        local output_name=`echo $2/load-fs-$fs-$1.txt`
        #echo "Output: $output_name"
        while [ $idx -le $ts ] ; do
            local counter=`printf "%d" ${matrix[$fs,$idx]}`
            echo $counter >> $output_name
            #printf "Matrix[$fs, $idx] val: %d\n" ${matrix[$fs,$idx]}
            idx=$((idx+1))
        done
    done
}
